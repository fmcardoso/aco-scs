#!/usr/bin/python3
import pants
import operator
import copy
from pygraph.classes.digraph import digraph
from pygraph.algorithms.cycles import find_cycle

class Edge:
  def __init__(self, source, target, weight):
    self.source = source
    self.target = target
    self.weight = weight
    self.valid = True

  def __repr__(self):
    return "{%s, %s, %s, %s}" % (self.source, self.target, self.weight, self.valid)

  def __str__(self):
    return "{%s, %s, %s, %s}" % (self.source, self.target, self.weight, self.valid)

class Graph:
  def __init__(self, vertexes):
    self.edges = []
    self.vertexes = vertexes
    
  def __repr__(self):
    return "{%s, %s}" % (self.edges, self.vertexes)

  def getEdge(self, x, y):
    for edge in self.edges:
      if edge.source==x and edge.target==y:
            return edge
    return None

class Solution:
  def __init__(self):
    self.vertexes = []
    self.sequence = ''
   
  def __repr__(self):
    return "{%s, %s}" % (self.sequence, self.vertexes)
 
def find_overlap(node1, node2):
  overlap = 0;
  for i in range(0, len(node2), 1):
    if (node1.endswith(node2[0:i+1])):
      overlap = i+1 # CASO EXISTA ARESTA, RETORNA O TAMANHO
  return overlap

def build_graph(nodes):
  graph = Graph(nodes)
  print(graph.vertexes)
  edges = []
  for x in range(0, len(nodes)):
    for y in range(0, len(nodes)):
      if x!=y:
        edges.append(Edge(x, y, find_overlap(nodes[x], nodes[y])))
  graph.edges = sorted(edges, key=lambda edge: edge.weight, reverse=True)
  return graph
  
def build_graph_to_find_cycle(nodes):
  graph = digraph()

  for x in range (0, len(nodes)):
    graph.add_node(x)
  
  return graph

def hasCycle(digraph, edge):
  digraph.add_edge((edge.source,edge.target), edge.weight)
  if not find_cycle(digraph):
    return False
  else: return True

def join(finalSolution):
  if (len(finalSolution) > 1):
    for solution in finalSolution:
      for solution2 in finalSolution:
        if (solution!=solution2):
          if solution.vertexes[-1] == solution2.vertexes[0]:
            partialSolution = Solution()
            solutionToRemove1 = solution
            solutionToRemove2 = solution2
            for x in range(0, len(solution.vertexes)):
              partialSolution.vertexes.append(solution.vertexes[x])
            for x in range(1, len(solution2.vertexes)):
              partialSolution.vertexes.append(solution2.vertexes[x])
            partialSolution.sequence = solution.sequence + solution2.sequence[len(graph.vertexes[solution.vertexes[-1]]):]
    finalSolution.remove(solutionToRemove1)
    finalSolution.remove(solutionToRemove2)
    finalSolution.append(partialSolution)
    join(finalSolution)
  else: return finalSolution

def assembyFragment(path):
  finalSolution = []

  for edge in path.edges:
    solution = Solution()
    solution.vertexes.append(edge.source)
    solution.vertexes.append(edge.target)
    solution.sequence += nodes[edge.source] + nodes[edge.target][edge.weight:]
    finalSolution.append(solution)

  join(finalSolution)
  return finalSolution

nodes = []
# nodes.append('ACTACAC')
# nodes.append('CACTCAGGCA')
# nodes.append('GCATTCACTA')
# nodes.append('ACTAGAAATATA')
# nodes.append('TATACCAGC')  
fragFileName = "gen/fragments.txt"
fragFile = open(fragFileName, "r")
fragments = fragFile.readlines()
fragments = [x.strip('\n') for x in fragments]
for frag in fragments:
    nodes.append(frag)
fragFile.close()

graph = build_graph(nodes)

###GRAFO UTILIZADO PARA VERIFICAR A EXISTÃŠNCIA DE CICLO
digraph = build_graph_to_find_cycle(nodes)
# print('Graph: ', graph, '\n')

path = Graph([])

#### ENCONTRAR CAMINHO HAMILTONIANO
for edge in graph.edges:
  for x in path.edges:
      if edge.source == x.source:
        edge.valid = False
      else:
        if edge.target == x.target:
          edge.valid = False
        else:
          if hasCycle(copy.deepcopy(digraph), copy.deepcopy(edge)):
            edge.valid = False

  if (edge.valid):
    path.edges.append(edge)
    digraph.add_edge((edge.source,edge.target), edge.weight)

    if edge.source not in path.vertexes:
      path.vertexes.append(edge.source)
    if edge.target not in path.vertexes: 
      path.vertexes.append(edge.target)

#### MONTAR A SEQUENCIA ORIGINAL
assembledSequence = assembyFragment(copy.deepcopy(path))

print('Tamanho da sequencia montada: ', len(assembledSequence[0].sequence))
